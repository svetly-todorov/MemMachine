name: Run REST Client Integration Tests

on:
  push:
    branches: [ main ]
  pull_request:
    # Regular PR event - runs without secrets (for fork PRs)
  pull_request_target:
    # This event has access to secrets but requires manual approval via label
    # Only triggers when a label is added (for security)
    types: [labeled]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write  # Required for pull_request_target to checkout PR code
  checks: write  # Required to update check status via API

# Cancel any preceding run on the pull request after a new commit is pushed or label is added.
# Use PR number for PR events, or ref for push events
# Same PR should share the same concurrency group regardless of event type (pull_request vs pull_request_target)
concurrency:
  group: rest-client-integration-test-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: ${{ (github.event.pull_request.head.ref || github.ref) != 'refs/heads/main' }}

jobs:
  rest-client-integration-test:
    # Set explicit check name so pull_request and pull_request_target use the same check
    # This ensures the successful pull_request_target run can replace the failed pull_request run
    name: REST Client Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Set job timeout to 30 minutes
    
    # For pull_request_target events, only run if the label is 'safe-to-test'
    # This ensures maintainers review code before secrets are exposed
    # Fork PR failures will block merge until 'safe-to-test' label is added and pull_request_target succeeds
    # When pull_request_target succeeds, it will update the pull_request check status to allow merge
    if: |
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'pull_request' ||
      (github.event_name == 'pull_request_target' && github.event.label.name == 'safe-to-test')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        # For pull_request_target: must explicitly checkout PR code (default is target branch)
        # For regular pull_request: checkout from fork if needed
        # For push/workflow_dispatch: checkout current branch
        with:
          ref: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.sha || github.event.pull_request.head.ref || github.ref }}
          repository: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.repo.full_name || github.event.pull_request.head.repo.full_name || github.repository }}

      - name: Check if fork PR without API key (fail early)
        id: check_fork_no_key
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_REPO="${{ github.event.pull_request.head.repo.full_name }}"
            MAIN_REPO="${{ github.repository }}"
            if [ "$PR_REPO" != "$MAIN_REPO" ]; then
              echo "::error::Fork PR detected without API key access"
              echo "‚ö†Ô∏è Fork PR detected without API key access"
              echo "Tests cannot run without secrets (OPENAI_API_KEY)"
              echo ""
              echo "üìã To run tests with secrets:"
              echo "   1. Review the PR code for security"
              echo "   2. Add 'safe-to-test' label"
              echo "   3. This will trigger pull_request_target event with secrets access"
              echo ""
              echo "This job will fail to indicate that tests were skipped due to missing secrets."
              echo "After maintainer adds 'safe-to-test' label and pull_request_target succeeds,"
              echo "this failed check will be updated to success automatically."
              exit 1
            fi
          fi
          echo "‚úÖ Not a fork PR or has secrets access - continuing with tests"

      - name: Display event information
        run: |
          EVENT_NAME="${{ github.event_name }}"
          if [ "$EVENT_NAME" = "pull_request_target" ]; then
            echo "‚úÖ pull_request_target event: Secrets are available (maintainer approved via label)"
            echo "   Label added: ${{ github.event.label.name }}"
          elif [ "$EVENT_NAME" = "pull_request" ]; then
            PR_REPO="${{ github.event.pull_request.head.repo.full_name }}"
            MAIN_REPO="${{ github.repository }}"
            if [ "$PR_REPO" != "$MAIN_REPO" ] && [ "$PR_REPO" != "N/A" ]; then
              echo "‚ÑπÔ∏è Fork PR: Secrets are NOT available"
              echo "   Tests requiring OPENAI_API_KEY will fail"
              echo "   Add 'safe-to-test' label to trigger pull_request_target event"
            else
              echo "‚úÖ Main repo PR: Secrets are available"
            fi
          elif [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            echo "‚úÖ Manual trigger: Secrets are available"
          else
            echo "‚úÖ Push event: Secrets are available"
          fi

      - name: Install the latest version of uv and set the python version
        uses: astral-sh/setup-uv@v6
        with:
          python-version: "3.12"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create .env file for Docker Compose
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Use secret if available, otherwise empty (tests requiring API key will fail)
          OPENAI_KEY="${OPENAI_API_KEY:-}"
          cat > .env << EOF
          POSTGRES_HOST=postgres
          POSTGRES_PORT=5432
          POSTGRES_USER=memmachine
          POSTGRES_PASSWORD=memmachine_password
          POSTGRES_DB=memmachine
          NEO4J_HOST=neo4j
          NEO4J_PORT=7687
          NEO4J_USER=neo4j
          NEO4J_PASSWORD=neo4j_password
          NEO4J_HTTP_PORT=7474
          NEO4J_HTTPS_PORT=7473
          MEMORY_CONFIG=/app/configuration.yml
          MCP_BASE_URL=http://memmachine:8080
          GATEWAY_URL=http://localhost:8080
          FAST_MCP_LOG_LEVEL=INFO
          OPENAI_API_KEY=${OPENAI_KEY}
          LOG_LEVEL=INFO
          MEMORY_SERVER_PORT=8080
          MEMMACHINE_IMAGE=memmachine/memmachine:latest-cpu
          EOF

      - name: Install PyYAML for configuration processing
        run: |
          pip install pyyaml

      - name: Prepare configuration.yml for CI
        env:
          # Only use secret if available (not a fork PR)
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Verify sample config exists
          if [ ! -f "sample_configs/episodic_memory_config.cpu.sample" ]; then
            echo "‚ùå Error: sample_configs/episodic_memory_config.cpu.sample not found"
            exit 1
          fi
          
          # Copy sample config if configuration.yml doesn't exist
          if [ ! -f "configuration.yml" ]; then
            echo "Copying sample config to configuration.yml..."
            cp sample_configs/episodic_memory_config.cpu.sample configuration.yml
          else
            echo "Using existing configuration.yml"
          fi
          
          # Verify configuration.yml was created
          if [ ! -f "configuration.yml" ]; then
            echo "‚ùå Error: Failed to create configuration.yml"
            exit 1
          fi
          
          # Use Python to safely update configuration.yml
          python3 << 'PYTHON_SCRIPT'
          import yaml
          import os
          import sys
          
          config_file = 'configuration.yml'
          with open(config_file, 'r') as f:
              config = yaml.safe_load(f)
          
          # Update database configurations
          if 'resources' in config and 'databases' in config['resources']:
              # Update PostgreSQL config
              if 'profile_storage' in config['resources']['databases']:
                  db_config = config['resources']['databases']['profile_storage']['config']
                  db_config['host'] = 'postgres'
                  db_config['user'] = 'memmachine'
                  db_config['password'] = 'memmachine_password'
                  db_config['db_name'] = 'memmachine'
              
              # Update Neo4j config
              if 'my_storage_id' in config['resources']['databases']:
                  neo4j_config = config['resources']['databases']['my_storage_id']['config']
                  neo4j_config['uri'] = 'bolt://neo4j:7687'
                  neo4j_config['username'] = 'neo4j'
                  neo4j_config['password'] = 'neo4j_password'
          
          # Update API key in embedders
          if 'resources' in config and 'embedders' in config['resources']:
              for embedder_name, embedder_config in config['resources']['embedders'].items():
                  if 'config' in embedder_config and 'api_key' in embedder_config['config']:
                      api_key = os.environ.get('OPENAI_API_KEY', '')
                      if api_key:
                          embedder_config['config']['api_key'] = api_key
          
          # Update API key in models
          if 'resources' in config and 'models' in config['resources']:
              for model_name, model_config in config['resources']['models'].items():
                  if 'config' in model_config and 'api_key' in model_config['config']:
                      api_key = os.environ.get('OPENAI_API_KEY', '')
                      if api_key:
                          model_config['config']['api_key'] = api_key
          
          with open(config_file, 'w') as f:
              yaml.dump(config, f, default_flow_style=False, sort_keys=False)
          PYTHON_SCRIPT

      - name: Build MemMachine Docker image
        run: |
          echo "Building MemMachine Docker image..."
          if [ ! -f "Dockerfile" ]; then
            echo "‚ùå Error: Dockerfile not found"
            exit 1
          fi
          docker build --build-arg GPU=false -t memmachine/memmachine:latest-cpu . || {
            echo "‚ùå Docker build failed"
            exit 1
          }
          echo "‚úÖ Docker image built successfully"
          echo "Built images:"
          docker images | grep memmachine || echo "No memmachine images found"

      - name: Start MemMachine services with Docker Compose
        run: |
          echo "Starting Docker Compose services..."
          docker compose up -d
          echo "Services started. Waiting for them to be ready..."
          sleep 10  # Give services a moment to start
          docker compose ps

      - name: Wait for PostgreSQL to be ready
        run: |
          echo "Waiting for PostgreSQL to be ready..."
          timeout 180 bash -c 'until docker exec memmachine-postgres pg_isready -U memmachine -d memmachine; do echo "$(date): Waiting for PostgreSQL..."; sleep 3; done'
          echo "PostgreSQL is ready"

      - name: Wait for Neo4j to be ready
        run: |
          echo "Waiting for Neo4j to be ready..."
          timeout 180 bash -c 'until docker exec memmachine-neo4j cypher-shell -u neo4j -p neo4j_password "RETURN 1" > /dev/null 2>&1; do echo "$(date): Waiting for Neo4j..."; sleep 3; done'
          echo "Neo4j is ready"

      - name: Wait for MemMachine API to be ready
        run: |
          echo "Waiting for MemMachine API to be ready..."
          timeout 300 bash -c 'until curl -f http://localhost:8080/api/v2/health > /dev/null 2>&1; do 
            echo "$(date): Waiting for MemMachine API..."
            echo "Checking container status..."
            docker ps | grep memmachine || echo "Container not running"
            echo "Last 20 lines of logs:"
            docker compose logs --tail=20 memmachine || true
            sleep 5
          done'
          echo "MemMachine API is ready"
          
      - name: Show service status
        run: |
          echo "=== Docker Compose Status ==="
          docker compose ps
          echo ""
          echo "=== MemMachine Container Status ==="
          docker ps -a | grep memmachine || echo "MemMachine container not found"
          echo ""
          echo "=== MemMachine Container Logs (last 100 lines) ==="
          docker compose logs --tail=100 memmachine || true
          echo ""
          echo "=== Checking if MemMachine container is running ==="
          if docker ps | grep -q memmachine-app; then
            echo "‚úÖ MemMachine container is running"
          else
            echo "‚ùå MemMachine container is NOT running"
            echo "=== Full MemMachine logs ==="
            docker compose logs memmachine || true
            exit 1
          fi

      - name: Verify MemMachine health
        run: |
          curl -f http://localhost:8080/api/v2/health || exit 1
          echo "MemMachine health check passed"

      - name: Install dependencies
        run: |
          uv sync --all-extras

      - name: Run REST client integration tests
        id: run_tests
        env:
          MEMORY_BACKEND_URL: http://localhost:8080
          # Secrets are available for: push, workflow_dispatch, main repo PRs, and pull_request_target (after label approval)
          # For fork PRs via pull_request event, secrets are NOT available and tests will fail if they need API key
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          EVENT_NAME="${{ github.event_name }}"
          echo "Running integration tests..."
          echo "Event: $EVENT_NAME"
          
          if [ "$EVENT_NAME" = "pull_request_target" ]; then
            echo "‚úÖ pull_request_target event: Running with secrets (maintainer approved via label)"
            echo "   ‚ö†Ô∏è  SECURITY NOTE: This test runs with secrets after maintainer approval via label"
          elif [ -z "$OPENAI_API_KEY" ]; then
            echo "‚ö†Ô∏è OPENAI_API_KEY is not available"
            echo "   This may be a fork PR (secrets not available in pull_request event)"
            echo "   Tests requiring API key will fail"
            echo ""
            echo "   üìã For maintainers: To run full tests with secrets for fork PRs,"
            echo "   add label 'safe-to-test' to trigger pull_request_target event"
          else
            echo "‚úÖ Running with OpenAI API key available"
          fi
          
          # Run all tests - if API key is missing and tests need it, they will fail
          uv run pytest tests/memmachine/rest_client/test_integration_complete.py -v --integration -m integration

      - name: Show service logs on failure
        if: failure()
        run: |
          echo "=== MemMachine logs ==="
          docker compose logs memmachine || true
          echo "=== PostgreSQL logs ==="
          docker compose logs postgres || true
          echo "=== Neo4j logs ==="
          docker compose logs neo4j || true

      - name: Update pull_request check status after pull_request_target success
        if: github.event_name == 'pull_request_target' && steps.run_tests.outcome == 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // When pull_request_target succeeds, update the failed pull_request check to success
            // This allows the PR to be merged even though the initial pull_request check failed
            const prNumber = context.payload.pull_request.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headSha = context.payload.pull_request.head.sha;
            
            console.log(`Looking for failed pull_request check for PR #${prNumber} (SHA: ${headSha})`);
            
            // Get all check runs for this PR head SHA
            const checks = await github.rest.checks.listForRef({
              owner: owner,
              repo: repo,
              ref: headSha,
            });
            
            // Find the failed pull_request check run (has "(pull_request)" suffix in name)
            const pullRequestCheck = checks.data.check_runs.find(
              check => check.name.includes('rest-client-integration-test') && 
                       check.name.includes('(pull_request)') &&
                       check.conclusion === 'failure'
            );
            
            if (pullRequestCheck) {
              console.log(`Found failed pull_request check: ${pullRequestCheck.name} (ID: ${pullRequestCheck.id})`);
              console.log(`Updating check status to success...`);
              
              // Update the check status to success
              await github.rest.checks.update({
                owner: owner,
                repo: repo,
                check_run_id: pullRequestCheck.id,
                status: 'completed',
                conclusion: 'success',
                output: {
                  title: 'Tests passed via pull_request_target',
                  summary: 'This check was updated to success after pull_request_target run succeeded with secrets.\n\n' +
                           'The pull_request_target check is the authoritative one after maintainer approval via the "safe-to-test" label.'
                }
              });
              
              console.log(`‚úÖ Successfully updated check ${pullRequestCheck.id} to success`);
            } else {
              console.log('‚ÑπÔ∏è No failed pull_request check found to update (may have been cancelled or already updated)');
            }

      - name: Cleanup
        if: always()
        run: |
          docker compose down -v

